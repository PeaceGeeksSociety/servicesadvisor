<?php
/**
 * @file
 * Code for the Services Advisor Notify feature.
 */

include_once 'services_advisor_notify.features.inc';

/**
 * Implements hook_sa_settings_form().
 *
 * @see services_advisor_base_settings_form().
 */
function services_advisor_notify_sa_settings_form($form, &$form_state) {

  $form['service_advisor_notify_expiry_cutoff'] = array(
    '#type' => 'textfield',
    '#title' => t('Service Location Expiration Notication Cutoff'),
    '#description' => t('How early should the expiry notifications be sent? Format using !url. Example "-1 week midnight". <strong>Reschedule notifications if you change this value!</strong>', array(
      '!url' => l('PHP Relative Formats', 'http://php.net/manual/en/datetime.formats.relative.php', array('attributes' => array('target' => '_blank')))
    )),
    '#default_value' => variable_get('service_advisor_notify_expiry_cutoff', '-1 week midnight')
  );

  $form['services_advisor_notify_bulk_schedule'] = array(
    '#type' => 'submit',
    '#value' => t('Bulk Reschedule Notifications'),
    '#submit' => array('services_advisor_notify_schedule_bulk')
  );

  return $form;
}

/**
 * Implements hook_node_presave().
 *
 * @todo  Make sure notification date is updated properly when changing the
 *        end date.
 */
function services_advisor_notify_node_presave($node) {
  services_advisor_notify_schedule_notification($node);
}

/**
 * Schedule expiry notifications for locations that are still active.
 */
function services_advisor_notify_schedule_notification($node) {
  if ($node->type == 'service_location' && $node->tnid > 0) {
    $wrapper = entity_metadata_wrapper('node', $node);
    $now = time();
    $expiry = $wrapper->field_service_end_date->value();
    $cutoff = services_advisor_notify_cutoff($expiry);

    if ($expiry > $now) {
      node_scheduler_schedule_action($node->tnid, 'service_expiring', $cutoff);

      return true;
    }
  }

  return false;
}

/**
 * Return the timestamp when messages should be sent out.
 *
 * @todo  Make this configurable.
 */
function services_advisor_notify_cutoff($expiry) {
  $cutoff = variable_get('service_advisor_notify_expiry_cutoff', '-1 week midnight');
  return strtotime($cutoff, $expiry);
}

/**
 * Implements hook_node_scheduler_action().
 */
function services_advisor_notify_node_scheduler_action($nid, $schedule_key) {
  switch ($schedule_key) {
    case 'service_expiring':
      $service = node_load($nid);
      $message = message_create($schedule_key);
      $wrapper = entity_metadata_wrapper('message', $message);
      $wrapper->field_service_message_service->set($service);
      $wrapper->save();

      message_subscribe_send_message('node', $service, $message);
      break;
  }
}

function services_advisor_notify_schedule_bulk() {
  $count = 0;
  $query = db_select('node', 'n')
    ->fields('n', array('nid'))
    ->condition('n.type', 'service_location')
    ->where('n.nid = n.tnid');
  $results = $query->execute()->fetchCol();

  foreach (node_load_multiple($results) as $node) {
    if (services_advisor_notify_schedule_notification($node)) {
      $count++;
    }
  }

  drupal_set_message(t('Rescheduled notifications for @count locations', array('@count' => $count)));
}

/**
 * Implements hook_flag_access().
 */
function services_advisor_notify_flag_access($flag, $entity_id, $action, $account) {
  if ($flag->name == 'subscribe_to_partner_nofications') {
    return og_user_access('node', $entity_id, 'access partner notifications', $account);
  }
}

/**
 * Implements hook_og_membership_insert().
 *
 * When a user joins a group set the notifications flag.
 */
function services_advisor_notify_og_membership_insert($og_membership) {
  if ($og_membership->entity_type == 'user') {
    $flag = flag_get_flag('subscribe_to_partner_nofications');
    $account = user_load($og_membership->etid);

    $flag->flag('flag', $og_membership['gid'], $account);
  }
}

/**
 * Implements hook_og_membership_delete().
 *
 * When a user leaves a group unset the notifications flag.
 */
function services_advisor_notify_og_membership_delete($og_membership) {
  if ($og_membership->entity_type == 'user') {
    $flag = flag_get_flag('subscribe_to_partner_nofications');
    $account = user_load($og_membership->etid);

    $flag->flag('unflag', $og_membership['gid'], $account);
  }
}

/**
 * Implements hook_og_permission().
 */
function services_advisor_notify_og_permission() {
  return array(
    'access partner notifications' => array(
      'title' => t('Access Partner Notifications'),
      'description' => t('Allows access to the notification subscribe flag displayed on partners.'),
      'default role' => array(OG_AUTHENTICATED_ROLE, OG_ADMINISTRATOR_ROLE),
    )
  );
}
